# 选择与放置策略分开

在Packing问题中，物品选择和物品放置属于两种不同的策略，

- [x] 对应到代码中，CutSearch部分完成放置策略，TopSearch和PlateSearch部分完成物品选择策略。
- [x] 目前 beam_search 框架依赖三个参数：① topSearch分支数目；② plateSearch 分支数目； ③ cutSearch 栈中物品数目



# TopSearch

顶层搜索首先要保证满足物品的顺序约束，然后需要尽可能的尝试更好的物品组合。

其中可能用到一些随机或是启发式的策略，有待仔细研究，目前使用的是随机挑选符合面积约束的物品。



## 为每块原料挑选物品策略

1. 程序运行初始阶段，先是随机的挑选物品，放置在原料上，同时记录物品在该原料上的利用率分布值
2. 待收集到一定数目的值以后，开始按照策略挑选物品，此时可以将挑选物品的问题看作是**带顺序约束的背包问题**，数学模型如下：

    > **已知**
    > 原料面积：$C$
    > 栈的数目：$S$
    > 每个栈中物品数目：$N[i]$
    > 每个栈中物品的面积：$A[i][j]$
    > 每个栈中物品的价值：$P[i][j]$
    > $i, j \in Z \and i \in [0, S), j \in [0, N[i])$
    >
    > **决策**
    > 选择栈i的前多少个物品：$x_i$
    > $x_i \in Z \and x_i \in [0, N[i]]$
    >
    > **约束**
    > 选择物品的面积和不小于原料的面积：
    > $\sum_{i = 0}^S{\sum_{j = 0}^{x_i}{A[i][j]}} \geq C$
    > 选择物品的面积和不大于原料面积的$\alpha$倍：
    > $\sum_{i = 0}^S{\sum_{j = 0}^{x_i}{A[i][j]}} \leq \alpha \cdot C$
    >
    > **目标**
    > 最大化选择物品的价值：
    > $\max \sum_{i = 0}^S{\sum_{j = 0}^{x_i}{P[i][j]}}$



## 分支数目

- [x] 使用固定参数控制，增大参数，效果明显，但可能会搜不完；
- [ ] 多个分支，选择前 n 个好的往下走完



## 反馈

- [ ] 从利用率最差的前 n 块开始重新走到底，考虑：优度、层数、选中次数、瑕疵数……



# PlateSearch

算法描述：接受原料编号和可用物品的组合，输出该组合下的最优局部解，其目标是尽量提高本块原料的利用率，而其停止条件是本块原料上无法再放进去更多的物品。

输入：原料id，随机数发生器，计时器，辅助数据

输出：对应原料上的可行解，解的目标函数值



## 为每个1-cut挑物品的策略

- [ ] 挑物品的策略要具有多样性（有大有小）；



## 分支数目

- [x] 使用固定参数控制，增大参数，效果明显，但可能会搜不完；
- [ ] 多个分支，选择前 n 个好的往下走完



# CutSearch

算法描述：DFS将候选栈中的物品放置成当前1-cut最优解。

- [ ] 比较两版cutSearch的求解质量和求解时间；
- [ ] 将cutSearch代码参数化，使用参数控制优度和速度（More：将每一层都设置成参数可控的优度、速度两套代码）

- [ ] 当前条件是1-cut拓宽宽度不能超过物品宽度的一半，是否可以考虑设定一个利用率下界α，保证利用率不低于α；如果在此约束下物品放不完，则将其放回栈中，下次再放置；

- [ ] 允许cutSearch访问物品栈，从中弹出几个物品填充当前cut，难点：保证物品顺序；



# MCTS 

- 每次从根节点出发
- 评价标准如何设定？
- 一次分一支 vs 一次分多支
- 挑物品策略怎样能使得分支完整？如果不能，则类似 *alpha go* 一次也不能穷举完所有分支的情况
- 相关论文：Guiding Combinatorial Optimization with UCT

# 关于程序性能分析测试

- [ ] 对比考虑瑕疵和不考虑瑕疵下程序算得得利用率有哪些不同？(注：该测试用于分析瑕疵对算法性能得影响。)

# 策略的组合方法

## beam_search特点
### 优点
+ 速度快，可以快速构造解。
+ 可以增大每层探测的分支数目。
+ 可以算得一个较好得利用率。
## 缺点
+ 无法保证解的最优性。
+ 严重依赖解的评估策略设计。
+ 严重依赖分支参数的设定。

## pfs特点
### 优点
+ 在充分搜索的情况下，可以得到最优解。
### 缺点
+ 依赖解的评估策略设计。
+ 速度较慢。

# 顶层局部搜索策略

# 伪代码

$S \leftarrow S_0$ // 构造初始解

# 寻找动作

while  不满足停止条件：

​	$Score_{average} \leftarrow S中每块原料的平均利用率$

​	对于S中所有利用率低于平均值的原料：

​		从该原料的前1至k块原料开始进行重新优化：

​			如果重新优化的k块原料的平均值有所提高，则退出。

重新构造完整的解并返回该解

+ 不考虑利用率的排序，直接从后向前屡？

# 挑物品权重

对物品原料对设置权重值，权重值和该物品放置在该块原料上的历史利用率有关。

+ 权重值更新公式：$P_{imk} = (1- \alpha) \cdot S_{imk} + \alpha \cdot P_{im(k-1)}$，其中$k$代表迭代轮次，$i$代表物品，$m$代表原料，$S$代表分数（物品所在原料的利用率），$\alpha$为权重衰减系数。
+ 根据权重值为原料挑选物品的策略：
  + 【难】对于当前原料，在原料面积约束的情况下，寻找物品组合使权重值最小（简化为1维背包问题，并需要考虑物品顺序约束）。
  + 【贪心】每次从物品栈首拿一个权重值最高的物品，直到达到一定容量限制。

