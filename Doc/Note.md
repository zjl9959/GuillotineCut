迭代模型中, 对于未放置的物品, 以 (当前原料上的余料面积 * 预计利用率) 为背包容量 求解不在当前一层桶放置的物品的背包问题
  如果全部放入, 则以 (物品面积之和 / 预计利用率 / 原料高度) 作为剩余物品占用宽度的估计, 总宽度为 (已固定宽度 + 当前一层桶宽度 + 剩余物品预计宽度)
  否则下面两种估计方式任选一种
    [优化当前原料利用率] 以 (放入该背包的物品面积之和 / 预计利用率 / 原料高度) 作为剩余物品占用宽度的估计, 总宽度为 (已固定宽度 + 当前一层桶宽度 + 剩余物品预计宽度)
      少放往往比多放好, 可能导致该策略过于 "胆小" 不敢放物品
    [优化全局利用率] 以 (未放入该背包的物品面积之和 / 预计利用率 / 原料高度) 作为剩余物品占用宽度的估计, 总宽度为 (包括当前原料在内所有已使用原料数 * 原料宽度 + 剩余物品占用宽度估计)

**当前原料无法放置物品时 (预判或求解失败), 强制要求一层桶宽度为剩余原料宽度再算一次, 取利用率较高的作为最终解? (避免在最后一块产生无法利用的区域)**

**如果有一部分区域无法达到估计的覆盖率, 会导致单纯形计算速度很慢, 且会得到只放一个物品的解!!!**
  一组 4 线程设成 0.9, 一组 4 线程设成 0.875? 挑实际利用率最高的
  **根据一定宽度范围内的瑕疵数量对利用率估计值进行下调** -r = 0.1 / (w / 400 + 1)
  **用机器学习估计利用率? 已知原料和成品的尺寸 (例如一个直观感受: 成品尺寸都很大时利用率很难特别高)**

使用快速版本构造初始解, 每次挑一个一层桶, 禁止讲某个当前放在其中的物品放在其中, 重新计算后续所有物品的放置方案

设置分支优先级削弱对称性防止总是放最后一个桶?

**如果成品有一个方向长度小于三层桶最小宽度和高度, 应考虑最小废料宽高固定其放置方向, 或者保证其恰好放进一个三层桶和二层桶不会产生废料**

**瑕疵比较少, 弄成惰性约束?**

优先放大的

**一次算多个大盒子, 同时可以考虑滑动窗口的模式 (一次算多个但是只固定一个)**

**迭代模型用 w + w' / o 作为目标, 其中 w 为当前大盒子的宽度, w' 为未放在当前大盒子中的物品所需的宽度下界, o 为最优利用率**
l' 可以用一维背包估计; 如果完全没有碎片, 利用率将为 100%, 而实际只能达到 o, 故将宽度下界除以 o 得到预期的宽度
**迭代模型用 r * w + r' * w' 作为目标, 其中 r 为当前大盒子的利用率, w 为当前大盒子的宽度, r' 为当前原料的剩余部分利用率上界, w' 当前原料的剩余可用宽度**
**估算放置剩余物品所需宽度的下界**
**估算当前原料的利用率上界**

**快速算的初始解代入完整模型?**

用箭头把同一个stack的item连起来 (鼠标点击生效?)

求解器总是优先选择把物品放在每一层最后一个桶里?
最大化覆盖面积的目标给桶加权重, 越靠前权重越大? (每个1层桶的前两个2层桶的第一个3层桶有额外奖励?)
或者分支优先级高且倾向于取1?

最大化覆盖面积的目标界很松? 算出来的界不是原料的面积而是成品的总面积?
根据物品大小添加 user cut 限制盒子大小

用大盒子套小盒子的指派模型, 设计局部搜索比拟物方法更靠谱, 但是需要一个寻找调整盒子大小适应成品大小并最小化重叠方案的算法

=============================

放置后果
  A 恰好放下
  B 向上撑大二层桶
  C 向右撑大一层桶
  D 与瑕疵重叠

分支策略
  对于每个栈顶成品
    对于旋转/不旋转
      放在当前二层桶/新建二层桶/新建一层桶
        尽量放在左下角并避开所有瑕疵 (从左下角开始向右/上平移分支, 贴不被支配的瑕疵, 保证最小废料宽高和一层桶最大宽度, 保证扩宽一层桶或增高二层桶不会导致切割穿过瑕疵)
        (向上平移必须贴在二层桶的上边缘, 且如果之后二层桶被撑大需要跟随其移动)

剪枝策略
  如果当前已使用的二层桶宽度超出了一层桶可用宽度, 再往二层桶里面放成品无意义
    为绕开瑕疵浪费的宽度也要算到已使用宽度中
    等价于新开一个一层桶, 里面只放该物品
    **成品当前旋转状态下宽度小于一层桶最小宽度时不等价**

Best-First-Search
通过限制搜索树深度增量来避免退化为广度优先搜索 (设置一定步长后必须扩展最深的叶子节点或者保证有一定概率扩展最深的叶子节点)

============================

- 方案
  - 混合整数规划
    - 完整模型直接求解
    - 拆分子问题调用模型迭代求解
      - 每次填充 k 块原料 (k 可能小于 1) 最大化放置成品总面积
      - 每次将所有有序订单列表的第一个未放置成品放入并最大化利用率 (放置成品总面积/使用原料宽度)
    - 类似于列生成构造中盒子和大盒子再拼接
      - 需要添加额外的约束确保包含同一个成品的组合只能出现一次, 否则每个成品只能出现在一个组合中
    - 挖掘 user cut/hint
      - Param: ObjScale/BranchDir/MIPFocus/Presolve/Symmetry
      - Attr: BranchPriority/VarHintPri/VarHintVal/Start
  - 局部搜索
    - ejection chain
    - 松弛超出原料边界
    - 固定完整模型中的部分变量 (一般为整数或布尔), 反复调模型
    - 限制最多翻转 k 个决策变量 (布尔) 或者限制决策变量数值变化总量 (整数)
  - 分支限界/蒙特卡洛树搜索
    - 估算放置剩余物品所需宽度的下界
    - 估算当前原料的利用率上界
    - 在一堆数中寻找一组数字, 使其求和与给定数字最接近 (寻找恰好能拼出长或宽相等的成品组合)
    - 一个空闲区域放哪个候选区块好要看放置后生成的空闲区域, 哪个空闲区域好要看能不能更好地放置候选区块
    - 一个部分解的潜力与已放置块总面积, 未放置块总面积和可用区域面积相关 (在解空间中使用 A* 搜索)
  - 机器学习
    - 增强学习

- 任务分工
  - 阅读论文, 从参考文献中补充论文
  - 算例分析 (一个文件里每个算例一个子表, 前面基本信息后面分布情况)
    - 订单数, 有序订单列表数, 瑕疵数, 每块原料瑕疵数
    - 订单总面积, 瑕疵总面积
    - 原料块数下界 (用成品总面积比单块原料面积估算 / 用一维装箱或背包问题估算)
    - 各层盒子数上界 (考虑原料大小和宽度高度限制时横向纵向分别最多可以放置多少个成品)
    - 订单长宽分布, 订单列表大小分布, 瑕疵长宽分布
  - 计算结果分析
    - 提取本轮测试的最优解文件 (增加了时间后缀)
    - 合并两组最优解文件 (两个文件夹中, 无时间后缀)
    - 记录本轮各个算例最优目标函数值
  - 尽量每块玻璃多放的贪心算法
  - 估算盒子数的贪心算法
    - 所需原料块数
    - 每块原料所需切割的刀数
  - 多种解向量表示方式 (切割数上的玻璃位置大小/每一刀在哪切) 导出到组委会要求的格式
    - 组委会要求的输出格式
    - 切割位置的数组
    - 切割树
  - 精简checker代码以便输出运行日志中调用
  - 估算放置剩余物品所需宽度的下界
  - 估算当前原料的利用率上界


加内存池

多业务最小化最大负载
方案一: 惰性添加约束
    初始模型只有带容量的多业务最短路模型
    之后每次得到一个可行解, 找到里面所有负载最大的链路, 添加约束限制该链路的负载必须小于当前最大负载
方案二: 主动添加约束
    初始模型只有带容量的多业务最短路模型
    之后通过不断减小所有链路的可用容量, 保证不会有链路超过当前最大负载
